import { promises as fsPromises, readFileSync } from 'fs';
import glob from 'globby';
import _rimraf from 'rimraf';
import { promisify } from 'util';

export const rimraf = promisify(_rimraf);

export const { readFile, writeFile } = fsPromises;
export { exists, readFileSync, statSync } from 'fs';

// Erasing old cache in __generated__ on HMR.
// Otherwise the multiple `declare module "*/x.graphql"` are exposed.
export async function removeByPatterns(cwd: string, ...patterns: string[]) {
  const oldFiles = await glob(patterns, {
    cwd,
    absolute: true,
  });
  await Promise.all(oldFiles.map((f) => rimraf(f)));
}

const leadingStringOfGeneratedContent = '/* ';
const hexHashLength = 40;
export function withHash(sourceHash: string, content: string): string {
  return `${leadingStringOfGeneratedContent}${sourceHash}
 * This file is automatically generated by graphql-let. */

${content}`;
}

// TODO: Move to hash.ts
export function readHash(filePath: string): string | null {
  try {
    // Sync is the fastest for a limited sized file to read hash
    // https://gist.github.com/piglovesyou/537a8157ba691e8e9e023263bfc7838d
    const content = readFileSync(filePath, 'utf-8');
    const hash = content.slice(
      leadingStringOfGeneratedContent.length,
      leadingStringOfGeneratedContent.length + hexHashLength,
    );
    if (hash) return hash;
    return null;
  } catch (error) {
    if (error.code === 'ENOENT') return null;
    throw error;
  }
}
